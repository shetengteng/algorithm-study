# 数据结构和算法

![数据结构与算法](resource\数据结构与算法.jpg)

图书：
入门：
​	大话数据结构
​	**算法图解**
进阶：
​	数据结构与算法分析：java语言描述
面试：
​	剑指offer
​	编程珠玑
​	编程之美
经典：
​	算法导论
​	算法

殿堂级：

​	计算机程序设计艺术

闲暇：
​	算法之美
​	数学之美
​	算法帝国

https://github.com/wangzheng0822/algo

可视化算法

https://visualgo.net



## 基本算法

### 查找

#### 二分查找 Binary Search

折半查找法，最省内存的查找方式。

举例：0-99 查找23

![6.查找01](resource\6.查找01.jpg)

![6.查找02](resource\6.查找02.jpg)

时间复杂度分析：

![6.查找03](resource\6.查找03.jpg)

假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。k值就是缩小的次数，每次缩小都要进行比较操作，那么时间复杂度就是O(k)，而n/2<sup>k</sup> = 1,那么k为log<sub>2</sub>n ,则时间复杂度是O(logn)。查找很快，2的32次方的数量是42亿调数据，最多查询32次可以得到

> 二分查找简单实现：有序数组，没有重复元素

##### 非递归实现

```java
public static int search(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = (low + high) / 2;
        if(arr[middle] == value){
            return middle;
        }
        if(arr[middle] < value){
            low = middle+1;
        }else{
            high = middle-1;
        }
    }
    return -1;
}
```

注意点：

- 循环退出条件，是low<=high，而不是low<high
- middle的取值：如果high和low比较大，那么low+high可能会数字溢出，那么就要使用减法的操作方式low+(high-low)/2，考虑到性能可以low+(high-low)>>1
- low和high更新操作：low=middle+1 ，high=middle-1

##### 递归实现

```java
public static int search2(int[] arr,int value){
    int low = 0;
    int high = arr.length;
    return search(arr,low,high,value);
}

public static int search(int[] arr,int low,int high,int value){
    if(low>high){
        return -1;
    }
    int middle = low + ((high-low) >> 1);
    if(arr[middle] == value){
        return middle;
    }
    if(arr[middle] < value){
        return search(arr,middle+1,high,value);
    }
    if(arr[middle] > value){
        return search(arr,low,middle-1,value);
    }
    return -1;
}
```

##### 局限性

依赖**数组结构**，数组随机访问的时间复杂度是O(1)，如果是链表，则复杂度会很高
依赖**有序数组**
只能用于插入，删除不频繁的情况下，一次排序，多次查找的场景中使用，针对动态数据的集合，二分查找不再适用，动态数据使用二叉树查找。

数据量太小不适合，可以直接使用遍历

数据量太大也不适合，原因是二分查找基于数组，而数据量太大，1G的数组是连续的内存空间需要分配，本身就是一个问题，是否可以产生这么大的数组存储空间。

其他：

如果使用二分查找法查询1000w的数据，每个数据8bit，那么数据大小是80MB，可以使用二分查找，速度快，当然使用散列表和二叉树也是可以的，但是会产生额外的内存空间的开销。

##### 4种常见变形问题

###### 查找第一个值等于给定值的元素

![6.查找04](resource\6.查找04.jpg)

```java
public static int search01_1(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    boolean flag = false;
    int middle = -1;
    while(low <= high){
        middle = low + ((high - low) >> 1);
        if(value == arr[middle]){
            flag = true;
            break;
        }
        if(value < arr[middle]){
            high = middle - 1;
            continue;
        }
        if(value > arr[middle]){
            low = middle + 1;
        }
    }
    if(flag){
        // 表示得到了其中一个
        while(true){
            if(middle == 0){
                return middle;
            }
            if(arr[middle-1] != value){
                return middle;
            }
            middle --;
        }
    }
    return -1;
}
```

###### 查找最后一个值等于给定值的元素

思路类似于上一个

```java
public static int search02(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    boolean flag = false;
    int middle = -1;
    while(low <= high){
        middle = low + ((high - low) >> 1);
        if(value == arr[middle]){
            flag = true;
            break;
        }
        if(value < arr[middle]){
            high = middle - 1;
            continue;
        }
        if(value > arr[middle]){
            low = middle + 1;
        }
    }
    if(flag){
        // 表示得到了其中一个
        while(true){
            if(middle == arr.length - 1){
                return middle;
            }
            if(arr[middle+1] != value){
                return middle;
            }
            middle ++;
        }
    }
    return -1;
}
```

###### 查找第一个大于等于给定值的元素

如一个数组[1,3,5,7,8]，查找第一个大于等于6的元素，那么就是7

如一个数组[1,3,5,6,6,7,8]，查找第一个大于等于6的元素，那么就是第一个6

```java
public static int search03(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = low + ((high - low)>>1);
        if(value <= arr[middle]){
            // 当value小于当前的区域的时候
            if(middle == 0 || value > arr[middle-1]){
                // 这里如果不是0的话，就满足arr[middle-1] < value <= arr[middle]
                return middle;
            }else{
                high = middle - 1;
            }
        }else{
            low = middle + 1;
        }
    }
    return -1;
}
```

###### 查找最后一个小于等于给定值的元素

同上一个思路，代码如下

```java
public static int search04(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = low +((high - low)>>1);
        if(value >= arr[middle]){
            if(middle == arr.length - 1 || value < arr[middle + 1] ){
                return middle;
            }else{
                low = middle + 1;
            }
        }else{
            high = middle - 1;
        }
    }
    return -1;
}
```

实际中，二分查找固定值不会经常用到，经常用到的是查找近似位置

二分查找的注意点：终止条件，区间的上下界更新方法，返回值选择



#### 跳表 Skip List（支持二分查找的链表）

基于链表的改造，支持类似于二分查找算法
动态数据结构
支持快速的插入，删除，查找操作
redis中的有序集合Sorted Set使用的就是跳表操作

单链表，查询速度慢，时间复杂度是O(n)

![6.查找05](resource\6.查找05.jpg)

将每2个节点抽取一个，作为索引的节点，称为索引层

![6.查找06](resource\6.查找06.jpg)

增加一层索引层之后，如果要查询节点8，之前要从1到8遍历，那么需要6次操作，而从索引，查询3次到7的位置，然后从down下面的节点查找，只需要4次操作，**说明添加一层索引，遍历的节点少了，提升了效率**，如果再加一层索引，会如何？

![6.查找07](resource\6.查找07.jpg)

















### 搜索

### 

### 字符串匹配

数据结构

### 线性表

### 散列表

### 树

### 图









