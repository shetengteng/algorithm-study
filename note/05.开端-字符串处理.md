# 字符串处理

## 字符串匹配算法

> 在java的indexOf 和 python的find的函数底层使用的就是字符串匹配算法。

### 朴素匹配 BF

> Brute Force 暴力匹配算法，也称为朴素匹配算法，实现简单，但是性能不高

主串与模式串，字符串A中查找字符串B，那么字符串A就是主串，B就是模式串，主串长度n，模式串长度m，在主串中查找模式串，n>m，

在主串中，检查的起始位置从$[0,n-m]$开始匹配，共有n-m+1个长度为m的子串，匹配这些子串是否与模式串相同

![](resource\12.字符串匹配1.jpg)

时间复杂度：在最坏情况下，在最后才匹配到，那么在主串中需要遍历n-m+1次，而每次遍历需要对比模式串的每个字符，最坏情况下比对m次，那么就是(n-m+1)*m次操作，时间复杂度是O(mn)

在实际使用中，虽然BF的时间复杂度很高，但是由于匹配的字符串都是比较简短的，而且在匹配时，可能在中间就匹配到就停止了，大部分情况执行效率还是很高的。

由于BF实现逻辑简单，那么在满足性能的前提下，简单就是可靠。

### Rabin-Karp RK

> 使用哈希算法来实现高效字符串匹配
>
> 发明人是Rabin和Karp，在BF算法中引入哈希算法，降低时间复杂度

对主串中的0到n-m+1范围内的子串进行哈希存储，那么在模式串只要在哈希表中进行匹配即可，提高了效率

![](resource\12.字符串匹配2.jpg)

在生成散列表的时候，需要遍历子串存储hash值，那么遍历的效率无法提升，依然是n-m+1次，那么在哈希比对上可以进行计算哈希值上的优化

通过进制的方式来实现，对于英文字母，a-z使用26进制计算，并转换为10进制数值，而位数大小就是模式串大小m，如模式串是3个字母，对应的hash值如下所示

![](resource\12.字符串匹配3.jpg)

继续优化发现，子串与前后子串在最大位和最小位有不同，中间位数是相同的

![](resource\12.字符串匹配4.jpg)

s[i]与s[i-1]的起始位置有不同，得到之间规律

![](resource\12.字符串匹配5.jpg)

对进制可以先准备一个机制计算好的数组，数组大小是m，模式串的大小，下标就是位数，直接获取，节省了计算的时间

![](resource\12.字符串匹配6.jpg)

时间复杂度分析：

遍历n-m+1个节点，计算hash值（使用优化的算法，前后串是关联的，计算差异部分，不需要遍历子串），这里的复杂度是O(n)，模式串与子串hash值之间的比对的复杂度是O(1)，总共比较n-m+1次，那么复杂度也是O(n)，整体的复杂度是O(2n)，最终的复杂度是O(n)

当然这个hash算法的值可能会随着模式串的长度增加，hash值也随之增加，可以改变hash算法，如a-z对应数字求和，这样会有散列冲突，当散列冲突时候，再进行子串和模式串比较，有大量冲突的时候时间复杂度就退化为O(mn)。

上述的2中字符串模式匹配也可以用与二维数组的比较

![](resource\12.字符串匹配7.jpg)



### Boyer-Moore BM 

> 在文本编辑中，实现查找功能，如果是使用BF 和RK也可以实现，但是效率依然不是很高，而BM的效率比BF和RK要高
>
> 但是BM比较复杂

#### 核心思想

BF和RK的设计思路是主串不动，模式串依次后移比较

![](resource\12.字符串匹配8.jpg)

可以发现模式子串里面的字符都不相同，那么移动一位可定也是不匹配的，如果能多移动几位，是可以提升效率的，而BM的设计思路就是模式串与主串不匹配的时候，可以跳过一些肯定不匹配的字符，往后多滑动几位。

#### 原理分析

- 坏字符规则 bad character rule

  - 一般的匹配顺序是从模式串的下标从小到大的，而BM算法的匹配顺序则是从大到小
    ![](resource\12.字符串匹配9.jpg)
    ![](resource\12.字符串匹配10.jpg)

    在倒着匹配的时候，发现没有匹配上的**主串的字符**作为坏字符

    ![](resource\12.字符串匹配11.jpg)

    如此时c是坏字符，在模式串中abd没有c，那么abd就往后移动3位，再从模式串尾部开始匹配

    ![](resource\12.字符串匹配12.jpg)

    此时模式串最后一位d和主串a依然不匹配，主串的a作为坏字符，但是a在模式串中是第一个字符，说明不能按照之前那样直接移动3位，只能移动2位比较

    ![](resource\12.字符串匹配13.jpg)

    将坏字符对应模式串的下标记作S<sub>i</sub>，将如果坏字符在模式串中有相同的字符（从前往后查找，取得最后一个相同，从后往前是第一相同的，防止滑动过多），那么该字符的下标记作X<sub>i</sub>，如果没有相同字符，则X<sub>i</sub> = -1，那后移位数就是S<sub>i</sub> - X<sub>i</sub>

    ![](resource\12.字符串匹配14.jpg)

    在坏字符规则下，BM算法在最好情况下的时间复杂度是O(n/m)，但是光有坏字符还是不够的，如aaaaaaaaaaaaaaaa，模式串是baaa，则不会往后滑动，反而会往前移动3位，此时需要好后缀规则

- 好后缀规则 good suffix shift

  - 与坏字符类似，定义---好后缀字符

    如果模式串中倒数第三个位置匹配到了坏字符，那么后2个就是好后缀

    ![](resource\12.字符串匹配15.jpg)

    好后缀的匹配

    在模式串中如果找到了另一个好后缀u对应的子串u1，那么移动模式串将u1与u的位置对齐

    ![](resource\12.字符串匹配16.jpg)

    如果在模式串中找不到另一个等于u的子串，那么模式串直接移动到u的后面位置

    ![](resource\12.字符串匹配17.jpg)

    但是该情况滑动可能会有遗漏，有过度滑动的产生，因此需要在好后缀中进行细化。

    ![](resource\12.字符串匹配18.jpg)

    好后缀匹配的2中情况

    ![](resource\12.字符串匹配19.jpg)

    v表示u的子集，说明在模式串前缀中有u的子集，那么移动到子集开始的位置

    其中v是u中能和模式串前缀匹配的最长子串。

    ![](resource\12.字符串匹配20.jpg)

    在得到好后缀和坏字符的前提下，取其中移动位置个数最大的作为移动的值，避免坏字符移动为负数的情况。

#### 实现

关于坏字符，有了坏字符，那么需要在模式串中进行匹配，如果顺序查找，性能会有所降低，使用散列表存储模式串，这里的散列比较巧妙，使用数组来表示，数组的下标是匹配字符串的ascii码，值是该字符在模式串中的下标位置，如果有相同字符，以最后一个下标为准（匹配坏字符时，可以直接找到最后一个匹配的下标）。当然，如果模式串中的有其他特殊字符，不在ascii码中的，需要设计其他的散列方式

- 实现散列方式

![](resource\12.BM1.jpg)

这里bc表示模式串的匹配数组

```java
/**
	 * 表示自定义字符串匹配数组的大小
	 */
private static final int SIZE = 256;

private int[] generateBC(String modeStr){
    int[] bc = new int[SIZE];
    // 初始化bc，为-1 表示没有匹配到
    for(int i=0;i<SIZE;i++){
        bc[i] = -1;
    }
    // 将模式串中的字母匹配到bc中
    for(int i=0;i<modeStr.length();i++){
        // 计算模式串中每个字符对应的ascii
        int ascii = (int)modeStr.charAt(i);
        bc[ascii] = i;
    }
    return bc;
}
```

- 实现坏字符规则

在只匹配坏字符规则的情况下，不考虑Si-Xi为负数的代码如下，注意这里bc返回的是-1也是有讲究的，没有匹配到不能返回-2，返回-1在移动的情况下+1,正好等于坏字符串到模式串第一字符的长度。

```java
/**
	 * 进行匹配，返回匹配的第一个索引位置，-1表示没有找到
	 * @param modeStr
	 * @param mainStr
	 * @return
	 */
public int handle(String modeStr,String mainStr){
    int[] bc = generateBC(modeStr);
    int m = modeStr.length();
    int n = mainStr.length();
    for(int i=0;i<n-m;){
        // i 表示主串与模式串匹配的第一个字符
        // 模式串从后往前匹配
        int bad = -1;
        for(int j=m-1;j>=0;j--){
            // 找到第一个不匹配的坏字符
            if(mainStr.charAt(i+j)!=modeStr.charAt(j)){
                bad = j;
                break;
            }
        }
        // 匹配成功：说明找到了模式串在主串完全相同子串的位置
        if(bad == -1){
            return i;
        }
        // 否则移动到模式串倒着数第一个和坏字符串匹配的位置
        i += bad - bc[(int)mainStr.charAt(i+bad)];
    }
    return -1;
}
```

![](resource\12.BM2.jpg)

可以看做模式串先移动到i+j的位置，然后再向前移动x的举例，这样模式串的x与主串的i+j的字符就匹配上了。

- 实现好后缀规则

  - 在模式串中查找和好后缀匹配的另一个子串，获取好后缀子串
  - 在好后缀子串中，查找最长，可以和模式串前缀子串匹配的后缀子串
  - 在不考虑效率的情况下，可以暴力匹配查找

  优化方案：

  - 预先处理模式串的好后缀子串列表，通过长度记录模式串中的好后缀子串的全集

    ![](resource\12.BM3.jpg)

  - 引入关键变量suffix数组，数组的下标是后缀子串的长度，值是模式子串中除了好后缀子串以外，模式前缀中最后一个匹配好后缀串（以及好后缀串的子串）的位置，主要目的是用于查找模式前串{v}的索引

    ![](resource\12.BM4.jpg)

    如果上图中，如果好后缀子串是cab，cab在模式串前缀中就可以匹配到，那么匹配的位置就是0，如果好后缀子串是bcab，那么bcab在模式子串中是匹配不到的，因此是-1，但是在好后缀子串里面得到{v}，如cab，那么cab是可以匹配到位置为0的。先匹配好后缀，如果模式前缀串中没有匹配，然后再匹配好后缀的最大子串

    还需要定义好后缀子串是否是前缀子串，如上图中cab就是好后缀串和前缀串都匹配的情况

    ![](resource\12.BM5.jpg)

    prefix[3]=true表示cab即使前缀串，也是好后缀串，其他的后缀串的index都不是0

  实现suffix数组：使用了动态规划的思想，比较难理解，b表示模式串的char数组，每次遍历，比如i=3时，会先将b[3]与b[len-1]比较，相同则都前进一个就进行b[2]与b[len-2]比较；相同则记录下k的大小，以及对应的下标j，k就是b从后往前的匹配个数，匹配len-1成功，记录后1个字符对应的下标j，len-2匹配成功，记录一下后2个字符对应的j的位置，如果没有匹配上，则跳出循环，从i的下一个位置开始，而此时的i递增，又扩大了匹配范围，b[i]继续和b[len-1]开始匹配，这样最终匹配到的字符串的suffix，就字符串在不同长度下的最新位置，而最大的下标且值不为-1的表示最大公约字符串，注意需要prefix记录第一次suffix[k]值为0的情况

  ```java
  /**
  	 * 生成好后缀串匹配数组，下标是好后缀子串长度，
  	 * 值是好后缀子串在模式前缀串（除去好后缀串剩下的子串）的最后位置
  	 * @param modeStr
  	 * @param prefix 注意：prefix需要在函数外部初始化
  	 * @return
  	 */
  public int[] generateGS(String modeStr,boolean[] prefix){
      int m = modeStr.length();
      int[] suffix = new int[m];
      // 初始化都为-1 实际使用suffix是从下标1开始，0没有使用到
      for(int i=0;i<m;i++){
          suffix[i] = -1;
          prefix[i] = false; // 表示模式串的前缀和好后缀子串相同 为true
      }
      for(int i=0;i<m-1;i++){
          // 好后缀的长度k
          for(int j=i,k=0;j>=0;j--){
              // 使用动态规划不断移动到最优解，由于会不断到最优解，那么需要记录第一次为j为0时，prefix[k]=true
              if(modeStr.charAt(j) == modeStr.charAt(m-1-k)){
                  suffix[++k] = j;
                  if(j==0){
                      prefix[k] = true;
                  }
              }else{
                  break;
              }
          }
      }
      return suffix;
  }
  ```

  ![](resource\12.BM6.jpg)

  斜线棕色表示k与j-i之间的字符相同

  滑动位数判断

  - 假设好后缀的长度是k，坏字符对应的位置是j，如果能匹配到好后缀在前缀子串中的位置是x（suffix[k]=x)，那么主串需要移动k-x+1
    ![](resource\12.BM8.jpg)

  - 如果好后缀子串的位置在模式串前缀匹配，那么移动到该子串的位置下

    ![](resource\12.BM9.jpg)

  - 如果都没有匹配到，则整个后移m位

    ![](E:\algorithm-data-structure\note\resource\12.BM11.jpg)

```java
public int handle2(String modeStr,String mainStr){
    int m = modeStr.length();
    int n = mainStr.length();
    int[] bc = generateBC(modeStr);
    boolean[] prefix = new boolean[m];
    int[] suffix = generateGS(modeStr,prefix);
    for(int i=0;i<=n-m;){
        // i 表示主串与模式串匹配的第一个字符
        // 模式串从后往前匹配
        int bad = -1;
        for(int j=m-1;j>=0;j--){
            // 找到第一个不匹配的坏字符
            if(mainStr.charAt(i+j)!=modeStr.charAt(j)){
                bad = j;
                break;
            }
        }
        // 匹配成功：说明找到了模式串在主串完全相同子串的位置
        if(bad == -1){
            return i;
        }
        // 否则移动到模式串倒着数第一个和坏字符串匹配的位置(坏字符情况)
        int x = bad - bc[(int)mainStr.charAt(i+bad)];
        // 好后缀情况下
        int y = 0;
        // 好后缀的长度
        int gsl = m-1-bad;
        if(gsl>0){
            if(suffix[gsl]!=-1){
                y = bad - suffix[gsl] +1;
            }else{
                boolean flag = false;
                // 判断子串是否是模式串的前缀，否则是前缀的子串没有意义
                for(int r=bad+2;r<m;r++){
                    // 子串是模式串前缀有意义
                    if(prefix[m-r]){
                        y = r;
                        flag = true;
                        break;
                    }
                }
                if(!flag){
                    y = m;
                }
            }
        }
        i += Math.max(x,y);
    }
    return -1;
}
```

#### 性能分析

内存消耗：需要额外消耗3个数组，bc数组大小和字符集有关，suffix和prefix和模式串大小m有关，如果字符集很大，且对内存消耗要求严格，由于好后缀和坏字符是独立的，可以只使用好后缀规则，避免内存的消耗，但是BM的效率会有所降低

时间复杂度：对于模式串如“aaaaaaa”，那么预处理suffix和prefix的时间复杂度就是O(m<sup>2</sup>)

实际上，BM 算法的时间复杂度分析起来是非常复杂，这篇论文“<a href="http://dl.acm.org/citation.cfm?id=1382431.1382552">A new proof of the linearity of the Boyer-Moore string searching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 5n。这篇论文“<a href="http://dl.acm.org/citation.cfm?id=127830">Tight bounds on the complexity of the Boyer-Moore string matching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 3n



### KMP

> 算法的名称是从三位作者而来，Knuth Morris Pratt 
>
> 通过对模式串的预处理，时间复杂度是O(m+n)，比BM快
>
> 核心思想与BM类似，把不能匹配的称为坏字符，把已经匹配的称为好前缀

http://www.cnblogs.com/SYCstudio/p/7194315.html

![](resource\12.KMP1.jpg)

一般的比较过程，一个一个的比较，可以发现是**好后缀的后缀子串**和**模式串的前缀子串**进行比较，那么是否可以有其他的方式，可以快速移动模式串？

![](resource\12.KMP2.jpg)

#### 基本思想

如果在好后缀子串中有与模式串前缀子串相同，那么可以直接跳过无效子串，达到快速移动的目的。

![](resource\12.KMP4.jpg)

上图中aba是好后缀的后缀子串，也是模式串的前缀串，那可以直接移动到该位置，其中k是好后缀的后缀子串与模式串的前缀子串的**最大公约串的长度**，这里的长度是3，那么移动是j-k位

对应的最长可匹配后缀子串和最长可匹配前缀子串如下

![](resource\12.KMP5.jpg)

图中，对应的可匹配前缀子串的情况，只有a和aba，类似于BM算法的suffix，这里构造一个**next数组**（又称失效函数），用于存储最长可匹配前缀子串的**结尾字符的下标**

![](resource\12.KMP6.jpg)

如上图，aba在模式串的位置是[0,2]，那么前缀尾字符下标是2，在aba中，a是属于匹配字符，就是和尾部匹配，此时a的下标是0，那么next[2]就是0，next[k]=v，其中k是前缀结尾字符下标，v是最长可匹配前缀子串的尾字符下标

#### 实现

##### 失效函数计算方法

> next数组实现

实现方式1：使用最直接的方式实现，如模式串b，求next[4]的值，那么把b[0,4]的所有后缀串取出，一一比对，但是效率比较低

![](resource\12.KMP7.jpg)

实现方式2：使用动态规划来实现，下标从小到大，依次计算next数组的值，计算next[i]的时候，next[0]~next[i-1]已经计算出来了，那么next[i]可以在之前计算的值的基础上推导出来

如果next[i-1]=k-1，那么b[0,k-1]是b[0,i-1]的最长可匹配前缀子串，此时如果b[k]与b[i]匹配，那么可以依照之前的匹配结果next[i]=k

![](resource\12.KMP8.jpg)

假设b[0,i]的最长可匹配后缀子串是b[r,i]，那么去除最后一个字符，b[r,i-1]肯定是b[0,i-1]的可匹配后缀子串，但不一定是最长的。如果b[i]与b[k]不相同，那么就观察次长的，如果相同则是最长可匹配后缀子串。

我们假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1] 最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1] 的次长可匹配后缀子串 b[x, i-1] 对应的可匹配前缀子串 b[0, i-1-x] 的下一个字符 b[i-x] 是否等于 b[i]。如果等于，那 b[x, i] 就是 b[0, i] 的最长可匹配后缀子串

![](resource\12.KMP9.jpg)

重点是获取次长的可匹配后缀子串

可是，如何求得 b[0, i-1] 的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1] 的次长可匹配后缀子串，这个问题就变成，查找 b[0, y] 的最长匹配后缀子串的问题了。

![](resource\12.KMP10.jpg)	

按照这个思路，我们可以考察完所有的 b[0, i-1] 的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i] 就是 b[0, i] 的最长可匹配后缀子串。

```java
public int[] generateNexts(String modeStr){
    int m = modeStr.length();
    int[] next = new int[m];
    // 理论上应该是0，但是为了方便判断越界，同时为了方便判断第0位和第i位，这里设置为-1
    next[0] = -1;

    // j 表示 最长可匹配前缀子串尾字符下标
    // i 表示 前缀结尾字符下标
    // 从后往前的推导，计算next[i]时可以保证next[0]-next[i-1]已经计算过
    // 若以某一个结尾的子串不存在相同的前缀和后缀，这里重置为-1
    for(int i=1;i<m;i++){
        // j 是上一个的结果 如果没有匹配上值是-1
        int j = next[i-1];
        // 重点：此时j的值是next[i-1] 表示i-1的最长可匹配前缀，但是该前缀+b[i]不匹配b[j+1]
        // 那么寻找[0,i-1]的次最长可匹配前缀，次最长肯定是在最长可匹配前缀中的
        // 那么在最长可匹配前缀范围内的[0,j]再得到该范围的最长可匹配前缀进行匹配
        while(j != -1 && modeStr.charAt(i) != modeStr.charAt(j+1)){
            j = next[j];
        }
        if(modeStr.charAt(i) == modeStr.charAt(j+1)){
            next[i] = j+1;
        }else{
            next[i] = -1;
        }
    }
    return next;
}
```

##### 算法实现

```java
public int handle(String modeStr,String mainStr){
    int[] next = generateNexts(modeStr);
    int n = mainStr.length();
    int m = modeStr.length();
    for(int i=0,j=0;i<n;i++){
        // 如果不相同,当前j的位置是坏字符
        while(j>0 && mainStr.charAt(i) != modeStr.charAt(j)){
            // 将j的位置更替为最长可匹配前缀子串最后一个字符索引+1，然后进行比较
            j = next[j-1]+1;
        }
        // 表示字符相同，如果不相同，则i++，j=0，然后再继续比较
        if(mainStr.charAt(i) == modeStr.charAt(j)){
            j++;
        }
        if(j==m){
            // 找到模式串的第一个元素的位置
            return i-m+1;
        }
    }
    return -1;
}
```


完整的比对过程

![](resource\12.KMP3.gif)

#### 复杂度分析

空间复杂度：需要一个next数组，大小是m，空间复杂度是O(m)

时间复杂度：构建next数组，时间复杂度近似是O(m)，匹配部分的复杂度：，i 从 0 循环增长到 n-1，j 的增长量不可能超过 i，所以肯定小于 n。而 while 循环中的那条语句 j=next[j-1]+1，不会让 j 增长的，那有没有可能让 j 不变呢？也没有可能。因为 next[j-1] 的值肯定小于 j-1，所以 while 循环中的这条语句实际上也是在让 j 的值减少。而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)。两者之和是O(m+n)



### Trie树

> 字典树，处理字符串匹配的数据结构，用于解决在一组字符串集合中快速查询某个字符串的问题







### AC自动机