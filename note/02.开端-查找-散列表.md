# 数据结构和算法

![数据结构与算法](resource\数据结构与算法.jpg)

图书：
入门：
​	大话数据结构
​	**算法图解**
进阶：
​	数据结构与算法分析：java语言描述
面试：
​	剑指offer
​	编程珠玑
​	编程之美
经典：
​	算法导论
​	算法

殿堂级：

​	计算机程序设计艺术

闲暇：
​	算法之美
​	数学之美
​	算法帝国

https://github.com/wangzheng0822/algo

可视化算法

https://visualgo.net



## 查找

### 二分查找 Binary Search

折半查找法，最省内存的查找方式。

举例：0-99 查找23

![6.查找01](resource\6.查找01.jpg)

![6.查找02](resource\6.查找02.jpg)

时间复杂度分析：

![6.查找03](resource\6.查找03.jpg)

假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。k值就是缩小的次数，每次缩小都要进行比较操作，那么时间复杂度就是O(k)，而n/2<sup>k</sup> = 1,那么k为log<sub>2</sub>n ,则时间复杂度是O(logn)。查找很快，2的32次方的数量是42亿调数据，最多查询32次可以得到

> 二分查找简单实现：有序数组，没有重复元素

#### 非递归实现

```java
public static int search(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = (low + high) / 2;
        if(arr[middle] == value){
            return middle;
        }
        if(arr[middle] < value){
            low = middle+1;
        }else{
            high = middle-1;
        }
    }
    return -1;
}
```

注意点：

- 循环退出条件，是low<=high，而不是low<high
- middle的取值：如果high和low比较大，那么low+high可能会数字溢出，那么就要使用减法的操作方式low+(high-low)/2，考虑到性能可以low+(high-low)>>1
- low和high更新操作：low=middle+1 ，high=middle-1

#### 递归实现

```java
public static int search2(int[] arr,int value){
    int low = 0;
    int high = arr.length;
    return search(arr,low,high,value);
}

public static int search(int[] arr,int low,int high,int value){
    if(low>high){
        return -1;
    }
    int middle = low + ((high-low) >> 1);
    if(arr[middle] == value){
        return middle;
    }
    if(arr[middle] < value){
        return search(arr,middle+1,high,value);
    }
    if(arr[middle] > value){
        return search(arr,low,middle-1,value);
    }
    return -1;
}
```

#### 局限性

依赖**数组结构**，数组随机访问的时间复杂度是O(1)，如果是链表，则复杂度会很高
依赖**有序数组**
只能用于插入，删除不频繁的情况下，一次排序，多次查找的场景中使用，针对动态数据的集合，二分查找不再适用，动态数据使用二叉树查找。

数据量太小不适合，可以直接使用遍历

数据量太大也不适合，原因是二分查找基于数组，而数据量太大，1G的数组是连续的内存空间需要分配，本身就是一个问题，是否可以产生这么大的数组存储空间。

其他：

如果使用二分查找法查询1000w的数据，每个数据8bit，那么数据大小是80MB，可以使用二分查找，速度快，当然使用散列表和二叉树也是可以的，但是会产生额外的内存空间的开销。

#### 4种常见变形问题

##### 查找第一个值等于给定值的元素

![6.查找04](resource\6.查找04.jpg)

```java
public static int search01_1(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    boolean flag = false;
    int middle = -1;
    while(low <= high){
        middle = low + ((high - low) >> 1);
        if(value == arr[middle]){
            flag = true;
            break;
        }
        if(value < arr[middle]){
            high = middle - 1;
            continue;
        }
        if(value > arr[middle]){
            low = middle + 1;
        }
    }
    if(flag){
        // 表示得到了其中一个
        while(true){
            if(middle == 0){
                return middle;
            }
            if(arr[middle-1] != value){
                return middle;
            }
            middle --;
        }
    }
    return -1;
}
```

##### 查找最后一个值等于给定值的元素

思路类似于上一个

```java
public static int search02(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    boolean flag = false;
    int middle = -1;
    while(low <= high){
        middle = low + ((high - low) >> 1);
        if(value == arr[middle]){
            flag = true;
            break;
        }
        if(value < arr[middle]){
            high = middle - 1;
            continue;
        }
        if(value > arr[middle]){
            low = middle + 1;
        }
    }
    if(flag){
        // 表示得到了其中一个
        while(true){
            if(middle == arr.length - 1){
                return middle;
            }
            if(arr[middle+1] != value){
                return middle;
            }
            middle ++;
        }
    }
    return -1;
}
```

##### 查找第一个大于等于给定值的元素

如一个数组[1,3,5,7,8]，查找第一个大于等于6的元素，那么就是7

如一个数组[1,3,5,6,6,7,8]，查找第一个大于等于6的元素，那么就是第一个6

```java
public static int search03(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = low + ((high - low)>>1);
        if(value <= arr[middle]){
            // 当value小于当前的区域的时候
            if(middle == 0 || value > arr[middle-1]){
                // 这里如果不是0的话，就满足arr[middle-1] < value <= arr[middle]
                return middle;
            }else{
                high = middle - 1;
            }
        }else{
            low = middle + 1;
        }
    }
    return -1;
}
```

##### 查找最后一个小于等于给定值的元素

同上一个思路，代码如下

```java
public static int search04(int[] arr,int value){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int middle = low +((high - low)>>1);
        if(value >= arr[middle]){
            if(middle == arr.length - 1 || value < arr[middle + 1] ){
                return middle;
            }else{
                low = middle + 1;
            }
        }else{
            high = middle - 1;
        }
    }
    return -1;
}
```

实际中，二分查找固定值不会经常用到，经常用到的是查找近似位置

二分查找的注意点：终止条件，区间的上下界更新方法，返回值选择



> 数据结构

## 线性表

### 跳表 Skip List（支持二分查找的链表）

基于链表的改造，支持类似于二分查找算法
动态数据结构
支持快速的插入，删除，查找操作
redis中的有序集合Sorted Set使用的就是跳表操作

单链表，查询速度慢，时间复杂度是O(n)

![6.查找05](resource\6.查找05.jpg)

将每2个节点抽取一个，作为索引的节点，称为索引层

![6.查找06](resource\6.查找06.jpg)

增加一层索引层之后，如果要查询节点8，之前要从1到8遍历，那么需要6次操作，而从索引，查询3次到7的位置，然后从down下面的节点查找，只需要4次操作，**说明添加一层索引，遍历的节点少了，提升了效率**，如果再加一层索引，会如何？

![6.查找07](resource\6.查找07.jpg)

此时再找8这个节点，只需要3次操作

如果是5级索引

![6.查找08](resource\6.查找08.jpg)

之前查找62节点，需要遍历62个节点，现在需要11个节点

#### 时间复杂度

假设链表节点个数为n，一级索引的点是n/2，二级为n/4，那么k级是n/2<sup>k</sup>，最高级是2个节点，那么n/2<sup>k</sup> = 2 可以计算出共有k级的大小，k = log<sub>2</sub>n - 1，如果加上原始一层，那么就是log<sub>2</sub>n，如果每一层要遍历的节点个数是m的话，那么时间复杂度是O(mlogn)，而m是系数，则为O(logn)。而m是3，每一层只要遍历3个点

![6.查找09](resource\6.查找09.jpg)

从k级到k-1级时，y ，x，z节点，发现需要的节点在这3个节点范围内，最多到z即可判断具体位置，那么最多需要3个点。那么时间复杂度就是O(logn)

#### 空间复杂度

原始链表的节点个数是n，那么需要创建多余的索引节点，那么节点的个数是多少？计算等差数列，交错相减法可得结果n-2，那么空间复杂度就是O(n)

![6.查找10](resource\6.查找10.jpg)

如果不是每2个创建一个索引节点，而是每3个生成一个索引节点，那么索引情况如下

![6.查找12](resource\6.查找12.jpg)

![6.查找11](resource\6.查找11.jpg)

求和结果是n/2，空间复杂度还是O(n)，但是实际上减少了一般的索引存储。

在实际软件开发过程中，索引所占存储的空间比较少，只需要存储少量的关键字和指针，而真实的链表的节点需要存储数据，相比较之下，索引空间并不大。

#### 高效的动态插入和删除

跳表的动态插入，删除的时间复杂度也都是O(logn)，因为要查找到某个地方之后，插入相应的值，在查找的时候就是O(logn)，然后再插入操作是一个常量，故时间复杂度是O(logn)

![6.查找13](resource\6.查找13.jpg)

对于删除而言，如果是索引节点，也要跟着删除，使用双向链表可以获取到前驱节点。

#### 跳表索引的动态更新

当我们不断的向表中插入数据，不断的更新索引，就可能出现2个索引节点之间的链表节点特别多的情况，那么就要进行索引的更新，否则会退化成单链表结构。

![6.查找14](resource\6.查找14.jpg)

跳表是通过随机函数维护数据索引节点的平衡性，通过随机函数，得到要插入节点的层级k，

![6.查找15](resource\6.查找15.jpg)

#### 小结

跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。

跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。

redis为什么不用红黑树来实现有序集合，而使用跳表?

redis有序集合要实现的特点：插入一个数据，删除一个数据，查找一个数据，**按照区间查找数据**（在[100,200]中查找数据），迭代输出有序数列

插入，查找，删除，红黑树也可以实现，而且时间复杂度也是O(logn)，但是按照区间查找数据，跳表可以做到查询时间复杂度是O(logn)，然后依次遍历输出，比较高效，而红黑树则不行了。同时，跳表比红黑树易于实现。



## 散列表

由数组演化而来，使用hash函数计算得到散列值，进行标识。

![6.查找16](resource\6.查找16.jpg)

散列表通过散列函数把元素的键值映射为下标，然后在数组中存储对应的下标位置，查询的时候将元素通过散列函数生成键值在作为数组下标取查找。

### 散列函数

hash(key) 

特点：

散列函数计算得到的散列值是一个非负整数；
如果 key1 = key2，那 hash(key1) == hash(key2)；
如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

要找到一个不同的key对应的散列值都不一样的散列函数几乎是不可能的，无法避免**散列冲突**，同时数组空间有限，加大了散列冲突的可能性

下面是伪代码

```java
int hash(String key) {
  // 获取后两位字符
  string lastTwoChars = key.substr(length-2, length);
  // 将后两位字符转换为整数
  int hashValue = convert lastTwoChas to int-type;
  return hashValue;
}
```

### 散列冲突

如何解决散列冲突？

#### 开放寻址法

如果出现了散列冲突就重新探测一个空闲位置，将其插入，简单的方式有**线性探测 Linear Probing**

![6.查找17](resource\6.查找17.jpg)

##### 插入情况

当散列表中插入数据的时候，如果散列到某个位置存储已经被占用了，那么从当前位置，依次往后查找空闲，直到找到为止（黄色表示空闲）

##### 查找情况

![6.查找18](resource\6.查找18.jpg)

先hash一下，得到相应的位置，如果当前位置内存储的不是对应的值，则从当前依次遍历查找，直到空闲的位置为止。

##### 删除情况

删除时，不能简单的删除操作，因为超找到的时候，会在空闲位置停止，那么可以标记一个特殊值deleted，当查找时，如果是deleted则继续查找

![6.查找19](resource\6.查找19.jpg)

##### 缺点

当插入删除的数据越来越多，发生冲突的可能性越来越大，那么时间复杂度会趋于O(n)

#### 二次探测法

类似于线性探测，线性探测每次1步，而二次探测是k<sup>2</sup>步

#### 双重散列法

不仅仅使用一个hash算法，而是一组散列函数hash1(key),hash2(key)...hashk(key)，依次调用，直到找到空闲的位置

#### 装载因子

不论采用哪种探测方式，当散列表中的空闲位置不多的时候，散列冲突就会大大提高，为了保证效率，一般情况下尽可能保证散列表有一定的空闲槽位，使用装载因子表示空位的多少

计算公式：散列表的装载因子 = 填入表中的元素个数 / 散列表的长度

因子越大，表示槽位越少，冲突越多，散列表的性能会下降

#### 链表法（常用）

更加常用的散列冲突的解决方法，比开放寻址方式更加简单好用
![7.散列表1](resource\7.散列表1.jpg)

有槽(桶)的概念，当相同的hash值的时候，放在该槽位链表中，依次加入。

插入的复杂度是O(1)

查找和删除的时间复杂度和槽的长度成正比，对于均匀散列而言n表示槽的个数，k表示总共存储元素的数量，那么时间复杂度就是O(k/n)



### 优化散列表

如果使用之前的链表法，而别人在插入键值的时候，如果有意为之，传入大量的hash值相同的key，那么会将查询从O(1)退化到O(n)，那么可能会导致大量查询消耗cpu资源，从而达到无法响应其他的请求，造成DoS攻击，散列表碰撞攻击

如何设计一个好的散列表？

- 散列函数设计不能复杂：过于复杂的散列函数消耗很多计算时间，有性能影响
- 散列函数生成的值要尽可能随机均匀分布，避免或者最小化散列冲突

举例：

运动会学生参赛学号问题，将编号中的后2位作为散列值，同时可以将手机的后几位作为散列值，手机的前几位重复性很大，可以取手机号的后4位作为散列值---数据分析法

实现word的拼写检查功能，将每个字母的ascii进行进位相加，再和散列表的大小求余，取模，作为散列值，如nice单词的散列值计算。

```java
hash("nice")=(("n" - "a") * 26*26*26 + ("i" - "a")*26*26 + ("c" - "a")*26+ ("e"-"a")) / 78978
```

还有其他的方法获取散列值，直接寻址，平方取中，折叠，随机数法等。

#### 动态扩容

当散列表超过装载因子的时候，就会动态扩容，一般扩容一倍，那么扩容后，需要对散列表的值进行重新计算位置，放入到新的散列表中。

![7.散列表2](resource\7.散列表2.jpg)

装载因子的设置要权衡时间，空间复杂度，如果内存充裕，对执行效率很高要求，那么可以降低负载因子的值，如果内存紧张，对执行效率又要求不高，可以增加负载因子的值，甚至大于1

#### 避免低效扩容

大部分情况下插入和查询都很快，但是一旦达到了装载因子的阈值，需要进行扩容时有插入操作，那么这次插入就很慢，如1g的hash，需要扩容，那么就需要2g的空间，此时要等2g的hash值迁移完，再插入新值，显然时间消耗是很大的，因此可以通过暂时不迁移，而是申请一个新的区域，先将新值插入，而每次有新值插入，就将老区中的第一个搬移到新的区域中，从而达到均摊时间复杂度的目的。

![7.散列表3](resource\7.散列表3.jpg)

这种实现方式，时间复杂度就是O(1)

#### 选择解决散列冲突的方式

开放寻址的应用，LocalThreadMap使用
链表法的应用，LinkedHashMap使用

- 开放寻址

  - 优点：不需要拉链表，有效的利用cpu缓存加速，序列化容易
  - 缺点：删除数据麻烦，存储在一个数组中，冲突的代价高，装载因子不能太大，内存浪费多
  - 数据量较小，装载因子小，适合采用

- 链表法

  - 优点：内存利用率高，可以容忍大装载因子，开放寻址的因子为1就会大量的冲突，而链表法只是链表加长了，影响小

  - 缺点：需要维护链表，有额外的内存消耗，对小对象而言，比较消耗内存，同时在内存中不是连续的，无法使用cpu缓存加速（cpu有一个内部缓存最近使用的数据存储区域，最近访问原则）

  - 如果存储大对象，可以使用链表法，维护链表的指针相比而言微不足道。

  - 链表法改进：将链表部分改造为红黑树，跳表等动态数据结构，即使冲突在极端情况下，查询效率也是O(logn) 而不会退化为O(n)，有效的避免了hash碰撞攻击

    ![7.散列表4](resource\7.散列表4.jpg)

### HashMap实现细节

#### 初始大小16

java的HashMap的初始大小是16，如果知道数据量的大小，可以实现设置，避免动态扩容次数，大大提高hashMap的性能

#### 装载因子0.75

HashMap中超过容量的75%就会扩容，每次扩容到原来的2倍。

#### 链表法解决冲突

在HashMap中，使用的是链表法解决冲突，当链表的长度大于8，那么就会转换为红黑树，而当链表的个数小于8时，又会转变为链表，在数据量较小的情况下，红黑树需要维持平衡，比起链表而言，性能优势并不明显。

#### 散列函数

```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}
```

String的hashCode

```java
public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 && this.value.length > 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 < this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}
```

#### 特性
支持快速插入，查询，删除操作
内存占用合理
性能稳定，在极端的情况下，也不会退化到无法接受的地步

散列表设计思路：
一个合适的散列函数
一个合适的装载因子和动态扩容策略
一个合适解决散列冲突的方法



### LRU加入散列表优化

LRU的设计思路是通过链表，每次访问一个新元素自动添加到链表的尾部，如果链表达到设置的长度阈值，则从头部去除，如果访问的是已有的元素，先从链表中查询，然后将该元素移动到链表的尾部，整个过程中，查询的时间复杂度是O(n)。（添加元素，查找元素，删除元素的时间复杂度都是O(n)，因为要有查询操作）

如果和散列表结合起来，链表结构存储保持不变，在散列表中同样存储一份，用于查询，那么查询的时间复杂度是O(1)，优化了LRU的时间复杂度。

![7.散列表5](resource\7.散列表5.jpg)

 这里的hnext表示的散列表设计中的链表法去解决散列冲突。在该设计中会有2个链表，一个链表是原有的LRU的双向链表结构，一个是散列表用于解决散列冲突的单向链表。

分析：

- 查找一个元素：查找一个元素使用散列表的特点，时间复杂度是O(1)
- 删除一个元素：先超找该元素，时间复杂度是O(1)，然后使用双向链表找到前后节点执行删除操作，时间复杂度是O(1)
- 新增一个元素：新增一个元素，通过hash判断是否在槽位中，如果不在可以直接插入散列表中（如果满了，需要删除头部节点），同时在LRU链表的尾部节点添加元素，新增过程时间复杂度是O(1)



### Redis有序集合的应用

在跳表中，redis使用跳表存储集合，不过，也使用了散列表存储了一份，在每个数据元素上有key和score，跳表存储的是score部分的索引，而散列表使用的是key存储，即可以通过key来查找，也可以通过score来进行查找。

有序集合的操作：

- 添加一个成员对象
- 按照键值来删除一个成员对象
- 按照键值查找一个成员对象
- 按照分值分区查找数据
- 按照分值大小排序对象

如果按照score生成的跳表，那么按照key进行查找和删除就会遍历链表，速度很慢，如果使用散列表对key进行构建，那么删除和查找key对应的数据时间复杂度就是O(1)。

### LinkedHashMap 实现细节

Linked表示双向链表

是链表和散列表组合而成的，支持按照插入的顺序遍历数据，支持按照访问的顺序遍历数据

```java
HashMap<Integer, Integer> m = new LinkedHashMap<>();
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
// 按照插入的顺序 打印 3,1,5,2
```

按照访问的顺序遍历数据

无论是新增还是获取，LinkedHashMap等于是一个LRU链表，只要对数据有操作，就会放在链表的最后。

```java
// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序
HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
// 插入的顺序 3，1，5，2，再放入3覆盖，现在的顺序是1,5,2,3
// 再读取5，现在的顺序是1,2,3,5
```



## Hash算法

> 如何使用好hash算法

将任意长度的原始二进制值映射为固定长度的二进制串值（hash值）

特点：

- 从hash值不能反向推导出原始的数据（单向hash算法）
- 对输入数据敏感，即使改变一个bit，得到的hash值也大大不同
- 散列冲突的概率要很小，对不同的原始数据，得到相同的hash值的概率非常小
- hash算法的执行效率要高，针对较长文本，也要很快计算出hash值

### MD5算法

计算得出128bit二进制，这里用16进制表示

```java
MD5(" 今天我来讲哈希算法 ") = bb4767201ad42c74e650c1b6c03d78fa
MD5("jiajia") = cd611a31ea969b908932d44d126d195b

MD5(" 我今天讲哈希算法！") = 425f0d5a917188d2c3c3dc85b5e4f2cb
```

应用：

- 安全加密，最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。其他加密算法，比如DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）

  - 哈希值位数越多，hash冲突的概率越低

- 唯一标识，对一个资源进行hash，然后判断该资源是否已经存在

- 数据校验，作为资源的摘要，发现是否被篡改过

- 散列函数，作为散列函数使用。

- 脱库使用，添加salt，将用户名和密码进行绑定然后hash之后存入数据库作为密码比对。

### 负载均衡

负载均衡的算法很多，轮询，随机，加权轮询，如果要实现一个会话粘粘的负载均衡算法呢？即在同一个客户端上，在一次请求的会话中，所有的请求都路由在一个服务器上。

思路1：维护一张映射表，客户端ip或者会话id与服务器的编号映射起来，每次该客户有服务请求，都到映射的服务器上。

- 不足：客户端很多的情况下，映射表会很大，比较浪费内存空间；客户端的上下线，服务器的扩容，缩容都会导致映射的失败，维护映射表的成本很大。

思路2：使用hash算法，将用户的ip或者会话id进行hash，然后与服务器列表的大小进行取模计算，最后得到的就是被路由的服务器编号，把同一个ip的请求都路由到一个服务器上，还不需要维护映射表

### 数据分片

如何统计 搜索关键词 的出现次数？1T的文件，记录了用户的搜索关键词，快速统计出每个关键词被搜索的次数

难点1：文件很大，无法全部在内存中加载

难点2：如果使用一台机器处理这么多的数据，耗时会很长

解决：将数据进行分片，使用多台机器处理的方式，使用n台机器进行处理，对关键字进行hash，然后对hash值进行n取模之后，发送给对应的机器，这样每个机器统计的关键字的次数，最后合在一起就是最终结果。

如何快速判断图片是否在资源库中？1亿张图片，如何查找

将图片资源进行分片，n台机器，计算hash值后对n取模，分配到对应的机器上，等到搜索图片是否存在，则对图片hash取模后得到相应的机器，再在机器中查找（机器中维护当前存储图片的散列表）。

### 分布式存储

借助分片的思想，对数据进行hash处理后对机器个数取模进行缓存，但是如果数据量增加，原先的机器个数不足，需要扩容，那么再的取模计算访问就会造成错误，造成的后果就是，缓存没有找到，数据穿透缓存，直接访问数据库，发生雪崩效应，压垮数据库。

![7.散列表6](resource\7.散列表6.jpg)

使用**一致性哈算法**解决

假设k个机器，数据的hash范围[0,max]，将整个范围划分为m个小区，m远大于k，每个机器负责m/k个小区，有新机器加入，则将某几个小区间的数据搬移过去，redis的分布式集群就是使用一致性哈希来解决的。

通过hash形成一个环

https://www.sohu.com/a/158141377_479559









