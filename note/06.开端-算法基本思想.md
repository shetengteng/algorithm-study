## 算法基本思想

### 贪心算法 Greedy

> 经典应用：霍夫曼编码 huffman coding、Prim、Kruskal 最小生成树、Dijkstra 单源最短路径算法 

假设100kg背包，5种豆子，如何选择豆子让背包总价值最大
![](resource\15.greedy1.jpg)

按照单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆

很多问题可以使用贪心算法进行处理，但是有些问题是不可以的，特别是前面的选择会影响后面的选择的时候，如果计算有权图的最短路径，如果使用贪心算法得到的可能不是最短路径。

#### 实战分析

- 分糖果：m个糖果，n个孩子，m<n，每个糖果大小不等，孩子对糖果的大小需求也不同

  - 糖果大小s1…sm
  - 孩子对糖果需求的大小g1…gn
  - 分配糖果，如果满足最多的孩子？
  - 思路：如果能用小糖果满足，就没有必要使用大糖果，更大的糖果给需求更大的孩子，同时，从对糖果需求小的孩子开始先分配，因为满足大的需求和小的需求期望值是一样的，从小的开始分配，更容易满足条件。每次从糖果中找到最小的进行分配。

- 钱币找零钱：钱币面额，1,2,5,10,20,50,100元；不同面额的张数，c1,c2,c5,c10…c100。支付k元，最少需要多少纸币？

  - 使用面额大的支付，不够，再找次最大的，依次类推。

- 区间覆盖：n个离散区间，得到两两不相交，最多可以选择多少个？

  ![](resource\15.greedy2.jpg)

  将n个区间的最左端点lmin，和最右端点rmax，然后将n个区间按照起始点进行排序，每次选择的时候，左边的端点和已经覆盖的区间不重合，右端点始终尽可能的小，从而可以放置更多的区间。

  ![](resource\15.greedy3.jpg)

- 实现霍夫曼编码：

  - 1000个字符的文件，每个字符占用1byte，那么共需要8000byte存储，如何压缩存储？

  - 方式1：通过分析发现1000个字符中，只有6种不同的字符，如a,b,c,d,e,f,g，可以使用3个二进制就可以表示8个不同的字符，那么1000个字符只需要3000个bit存储

    a(000)、b(001)、c(010)、d(011)、e(100)、f(101)

  - 方式2：霍夫曼编码压缩，压缩率20%-30%，不但考察文本中有多少个字符，而且还会考察文本中字符出现的频率，依据不同的频率选择不同长度的编码；依据贪心算法的思想，把频率出现较多的字符，用短的编码，出现频率低的用长一点的编码

    - 对于等长的编码，压缩的时候简单，如方式1

    - 对于不等长的霍夫曼编码，压缩就比较复杂，就要求各个字符的编码之间，不会有某个编码是另一个编码的前缀的情况

    ![](resource\15.greedy5.jpg)

    ​	假设6个字符从高到低是a,b,c,d,e,f,g，任何一个编码都不是另一个的前缀，解压缩的时候，每次读取尽**可能长的可解压**的二进制串（先解压最长的），最终1000个字符只需要2100bit存储就可以了。

    ![](resource\15.greedy6.jpg)

    - 编码流程：读入文件–>第一次扫描文件，分析各个字符出现的频率--> 建立Huffman树 -->将码表以及必要信息输出文件-->对源文件进行编码输出。

    - 构建Huffman树：

    ![](resource\15.greedy7.jpg)

     把每个字符看做一个节点，并将频率作为值放入到**优先级队列**中，在队列中取出最小的2个节点，A，B，然后新建一个节点C，C的频率值是B和C的频率和。将C作为A，B的父节点。再把C放入到队列中。重复该过程，直到没有数据。

     在每条边上添加一个权值，左边线都是0，右边线是1，从根节点到叶子节点的边路径的权值对应的字符就是Huffman编码。

    ![](resource\15.greedy8.jpg)




### 分治算法



### 回溯算法



### 动态规划