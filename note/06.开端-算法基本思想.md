## 算法基本思想

### 贪心算法 Greedy

> 经典应用：霍夫曼编码 huffman coding、Prim、Kruskal 最小生成树、Dijkstra 单源最短路径算法 

假设100kg背包，5种豆子，如何选择豆子让背包总价值最大
![](resource\15.greedy1.jpg)

按照单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆

很多问题可以使用贪心算法进行处理，但是有些问题是不可以的，特别是前面的选择会影响后面的选择的时候，如果计算有权图的最短路径，如果使用贪心算法得到的可能不是最短路径。

#### 实战分析

- 分糖果：m个糖果，n个孩子，m<n，每个糖果大小不等，孩子对糖果的大小需求也不同

  - 糖果大小s1…sm
  - 孩子对糖果需求的大小g1…gn
  - 分配糖果，如果满足最多的孩子？
  - 思路：如果能用小糖果满足，就没有必要使用大糖果，更大的糖果给需求更大的孩子，同时，从对糖果需求小的孩子开始先分配，因为满足大的需求和小的需求期望值是一样的，从小的开始分配，更容易满足条件。每次从糖果中找到最小的进行分配。

- 钱币找零钱：钱币面额，1,2,5,10,20,50,100元；不同面额的张数，c1,c2,c5,c10…c100。支付k元，最少需要多少纸币？

  - 使用面额大的支付，不够，再找次最大的，依次类推。

- 区间覆盖：n个离散区间，得到两两不相交，最多可以选择多少个？

  ![](resource\15.greedy2.jpg)

  将n个区间的最左端点lmin，和最右端点rmax，然后将n个区间按照起始点进行排序，每次选择的时候，左边的端点和已经覆盖的区间不重合，右端点始终尽可能的小，从而可以放置更多的区间。

  ![](resource\15.greedy3.jpg)

- 实现霍夫曼编码：

  - 1000个字符的文件，每个字符占用1byte，那么共需要8000byte存储，如何压缩存储？

  - 方式1：通过分析发现1000个字符中，只有6种不同的字符，如a,b,c,d,e,f,g，可以使用3个二进制就可以表示8个不同的字符，那么1000个字符只需要3000个bit存储

    a(000)、b(001)、c(010)、d(011)、e(100)、f(101)

  - 方式2：霍夫曼编码压缩，压缩率20%-30%，不但考察文本中有多少个字符，而且还会考察文本中字符出现的频率，依据不同的频率选择不同长度的编码；依据贪心算法的思想，把频率出现较多的字符，用短的编码，出现频率低的用长一点的编码

    - 对于等长的编码，压缩的时候简单，如方式1

    - 对于不等长的霍夫曼编码，压缩就比较复杂，就要求各个字符的编码之间，不会有某个编码是另一个编码的前缀的情况

    ![](resource\15.greedy5.jpg)

    ​	假设6个字符从高到低是a,b,c,d,e,f,g，任何一个编码都不是另一个的前缀，解压缩的时候，每次读取尽**可能长的可解压**的二进制串（先解压最长的），最终1000个字符只需要2100bit存储就可以了。

    ![](resource\15.greedy6.jpg)

    - 编码流程：读入文件–>第一次扫描文件，分析各个字符出现的频率--> 建立Huffman树 -->将码表以及必要信息输出文件-->对源文件进行编码输出。

    - 构建Huffman树：

    ![](resource\15.greedy7.jpg)

     把每个字符看做一个节点，并将频率作为值放入到**优先级队列**中，在队列中取出最小的2个节点，A，B，然后新建一个节点C，C的频率值是B和C的频率和。将C作为A，B的父节点。再把C放入到队列中。重复该过程，直到没有数据。

     在每条边上添加一个权值，左边线都是0，右边线是1，从根节点到叶子节点的边路径的权值对应的字符就是Huffman编码。

    ![](resource\15.greedy8.jpg)



### 分治算法 Divide and Conquer

> 分而治之，将问题划分为n个规模较小，并且结构与原问题相似的子问题，递归的解决这些子问题，然后再合并这些问题的结果，得到原问题的解。
>
> 分治算法是一种处理问题的思想，递归是一种编程技巧，分治算法一般都比较合适使用递归来实现。

分治算法的递归实现中，每一层都涉及到如下操作：

- 分解：将原问题分解成一系列的子问题
- 解决：递归的求解各个子问题，若子问题足够小，则直接解决
- 合并：将子问题的结果进行成原问题结果

分治算法解决的问题需要满足：

- 原问题和分解成的小问题具有相同的模式
- 原问题分解的子问题可以独立求解，子问题之间没有关联性（动态规划是子问题之间是关联的）
- 具有分解终止条件，当问题足够小的时候，可以直接解决
- 可以将子问题合并成原问题，合并操作的复杂度不能太高

示例：计算逆序度

假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度

![](resource\16.divide1.jpg)

最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。那有没有更加高效的处理方法呢

我们用分治算法来试试。我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3

归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了

![](resource\16.divide2.jpg)

```java
private int num = 0; // 全局变量或者成员变量

public int count(int[] a, int n) {
  num = 0;
  mergeSortCounting(a, 0, n-1);
  return num;
}

private void mergeSortCounting(int[] a, int p, int r) {
  if (p >= r) return;
  int q = (p+r)/2;
  mergeSortCounting(a, p, q);
  mergeSortCounting(a, q+1, r);
  merge(a, p, q, r);
}

private void merge(int[] a, int p, int q, int r) {
  int i = p, j = q+1, k = 0;
  int[] tmp = new int[r-p+1];
  while (i<=q && j<=r) {
    if (a[i] <= a[j]) {
      tmp[k++] = a[i++];
    } else {
      num += (q-i+1); // 统计 p-q 之间，比 a[j] 大的元素个数
      tmp[k++] = a[j++];
    }
  }
  while (i <= q) { // 处理剩下的
    tmp[k++] = a[i++];
  }
  while (j <= r) { // 处理剩下的
    tmp[k++] = a[j++];
  }
  for (i = 0; i <= r-p; ++i) { // 从 tmp 拷贝回 a
    a[p+i] = tmp[i];
  }
}
```



### 回溯算法 Back Track

处理思想类似于枚举搜索，枚举所有的解，找到满足期望的解，为了避免遗漏和重复，把问题的求解过程分成多次阶段，每个阶段都会有分支情况，随意走一个分支，当这个分支得不到期望的解，回退到上一个分支，继续执行。

#### 八皇后问题

8x8棋盘，放入8个棋子，每个棋子的行列，对角线都不能有另一个棋子，下图中左边满足，右边不满足

![](resource\17.backtrack1.jpg)

将该问题划分为8个阶段，每个阶段分别将棋子放在第一行，第二行，第三行…第八行，放置过程中，不断检查当前的方法是否满足要求，如果满足则跳到下一个继续放置，如果不满足，则再换一种方法。

回溯算法适合使用递归代码实现

```java
/**
	 * 下标表示行
	 * 值表示queen存储在哪一列
	 */
int[] result = new int[8];

public void calculate(int row){
    // 8个queen都放好了
    if(row == 8){
        // 每次等于8都打印出result
        printResult(result);
        return;
    }
    for(int column = 0;column < 8;column ++){
        // 每一行有8列，那么就有8种情况可以放置
        // 从第一行开始的8种情况，每次打印出result后，其他情况覆盖该result结果
        // 注意这里的for循环不是同步进行的，按照顺序依次往下，result没有冲突，公用一个
        if(handleColumn(row,column)){
            result[row] = column;
            // 计算下一行
            calculate(row + 1);
        }
    }
}

/**
	 * 判断当前行该列是否可以放置queen
	 * @param row
	 * @param column
	 * @return
	 */
public boolean handleColumn(int row,int column){
    // 左上角
    int leftup = column -1;
    // 右上角
    int rightup = column +1;

    //从row-1往上排查
    for(int i=row-1;i>=0;i--){
        // 该列有queen
        if(result[i] == column){
            return false;
        }
        // 左上角
        if(leftup >=0 && result[i] == leftup){
            return false;
        }
        // 右上角
        if(rightup < 8 && result[i] == rightup){
            return false;
        }
        leftup--;
        rightup++;
    }
    return true;
}

public void printResult(int[] re){
    int n = re.length;
    for(int row = 0;row < n; row++){
        for(int column=0;column < n;column++){
            if(re[row]!=column){
                System.out.print("*");
            }else{
                System.out.print("Q");
            }
        }
        System.out.println();
    }
    System.out.println();
}
```







































### 动态规划